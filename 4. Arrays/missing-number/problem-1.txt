Missing Number


Problem:
*********
Given an array nums containing n distinct numbers in the range [0, n], return the only number in the range that is missing from the array.


Example 1:
***********
Input: nums = [3, 0, 1]
Output: 2
Explanation:
1. n=3, since there are 3 numbers, so all numbers are in the range [0, 3]
2. 2 is the missing number in the range, since it does not appear in nums.


Example 2:
***********
Input: nums = [0, 1]
Output: 2
Explanation:
1. n=2, since there are 2 numbers, so all numbers are in the range [0, 2]
2. 2 is the missing number in the range, since it does not appear in nums.


Example 3:
***********
Input: nums = [9, 6, 4, 2, 3, 5, 7, 0, 1]
Output: 8
Explanation:
1. n=9 since there are 9 numbers, so all numbers are in the range [0, 9]
2. 8 is the missing number in the range, since it does not appear in nums.


Constraints:
*************
1. n == nums.length
2. 1 <= n <= 10^4
3. 0 <= nums[i] <= n
4. All the numbers of nums are unique


Approach 1: Brute force with sorting and comparison
************
1. Sort the array

2. Loop from index 1 to n-1
   (a) If nums[i] != nums[i-1] + 1, return nums[i-1] + 1 as the missing number

3. In no such mismatch is found:
   (a) If nums[0] != 0, return 0
   (b) Else return n


Time Complexity:
*****************
1. Time Complexity = O(n log n)
2. Due to sorting the array


Space Complexity:
******************
1. Space Complexity = O(1)
2. Sorting is done in-place and only a few variables are used.


Dry Run:
*********
nums = [4, 2, 1, 0, 5]

After Sorting, nums = [0, 1, 2, 4, 5]


i=1;  1 < 5  => true
nums[1] !== nums[0] + 1  => nums[1] !== 0 + 1  => 1 !== 1  => false

i=2;  2 < 5  => true
nums[2] !== nums[1] + 1  => nums[2] !== 1 + 1  => 2 !== 2  => false

i=3;  3 < 4  => true
nums[3] !== nums[2] + 1  => nums[3] !== 2 + 1  => 4 !== 3  => true


Output: 3
