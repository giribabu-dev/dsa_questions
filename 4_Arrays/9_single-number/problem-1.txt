Single Number


Problem:
*********
Given a non-empty array of integers nums, every element appears twice except for one. Find that single one.

You must implement a solution with a linear runtime complexity and use only constant extra space.


Examples:
**********
1. Input: nums = [2, 2, 1]  →  Output: 1
2. Input: nums = [4, 1, 2, 1, 2]  →  Output: 4
3. Input: nums = [1]  → Output: 1


Constraints:
*************
1. 1 <= nums.length <= 3 x 10^4
2. -3 x 10^4 <= nums[i] <= 3 x 10^4
3. Each element appears twice except one element that appears only once.


Approach 1: Brute Force (Hash Map)
************
1. Create an empty hash map to store counts of each element.
2. Loop through the array, update the count for each element.
3. Loop again to find the element with count 1 and return it.


Time Complexity:
*****************
1. Time Complexity = O(n)
2. We traverse the array twice: once for counting and once for checking.


Space Complexity:
******************
1. Space Complexity = O(n)
2. The hash map may store counts for up to n elements in the worst case.


Dry Run:
*********
nums = [4, 1, 2, 1, 2]

hash = {}

i=0;  0 < 5  => true
!hash[nums[0]]  => !hash[4]  => true
hash = { "4": 1 }

i=1;  1 < 5  => true
!hash[nums[1]]  => !hash[1]  => true
hash = { "4": 1, "1": 1 }

i=2;  2 < 5  => true
!hash[nums[2]]  => !hash[2]  => true
hash = { "4": 1, "1": 1, "2": 1 }

i=3;  3 < 5  => true
!hash[nums[3]]  => !hash[1]  => false
hash = { "4": 1, "1": 2, "2": 1 }

i=4;  4 < 5  => true
!hash[nums[4]]  => !hash[2]  => false
hash = { "4": 1, "1": 2, "2": 2 }

i=5;  5 < 5  => false


j=0;  0 < 5  => true
hash[nums[0]] === 1  => hash[4] === 1  => true

Return nums[0] is 4
